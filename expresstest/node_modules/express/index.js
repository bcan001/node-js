module.exports = require('./lib/express');

var express = require('express');
var app = express();
var server = require("http").createServer(app);


app.use(express.static(__dirname + '/public'));

var io = require('socket.io')(server);

var redis = require("redis");
var redisClient = redis.createClient();


///////////////////////////////
//var messages = [];


var users = 0;

io.on("connection", function(client) {
	console.log('client connected...');

	//var messages = [];
	var storeMessage = function(name, data) {
		// messages.push({ name: name, data: data }); // add each message to the end of an array
		// if (messages.length > 10) {
		// 	messages.shift(); // if more than 10 messages long, remove the first one
		// }
		// //console.log(messages);

		// now store in redis
		var message = JSON.stringify({ name: name, data: data }); // need to turn the object into a string to store in redis
		redisClient.lpush("messages", message, function(err, response){
			redisClient.ltrim("messages", 0, 9); // keep the newest 10 items
		});
	}


	// emit messages event on the client (see posts.html for event listener)
	//client.emit('messages', { hello: 'world'});

	client.on("join", function(name) {
		users += 1;
		console.log('There are currently ' +users+ ' users logged in!');

		redisClient.sadd("chatters", name); // add the name of the client to our redis set ‘chatters'


		client.broadcast.emit("add chatter", name); // notify other clients a chatter has joined
		// check to see if there are already users in the chatroom
		redisClient.smembers("chatters", function(err, names) {
			names.forEach(function(name) {
				client.emit("add chatter", name); // emit all the currently logged in chatters to the newly connected client
			});
		});
		//redisClient.sadd("chatters", name); // add the name of the client to our redis set ‘chatters'

		// when a client joins, we assign him a nickname
		client.nickname = name;
		// when another client joins, we need to iterate through the messages array and emit a message on the connecting client for each one
		// messages.forEach(function(message) {
		// 	client.emit("messages", message.name + ': ' + message.data);
		// });

		// now show from redis db
		redisClient.lrange("messages", 0, -1, function(err, messages) {

			messages = messages.reverse(); // reverse so they are emitted in correct order
			messages.forEach(function(message) {
				message = JSON.parse(message); // parse into JSON object so we can output it on the client
				client.emit("messages", message.name + ': ' + message.data);
			});
		});

	});



	client.on("messages", function(data) {
		console.log(data);

		var nickname = client.nickname;		
		// broadcast your message to all other clients
		client.broadcast.emit("messages", nickname + ': ' + data);
		// send the same message back to yourself
		client.emit("messages", nickname + ': ' + data);
		storeMessage(nickname, data); // when a client sends a message, call store message
	});


	client.on("disconnect", function(data) {
		console.log("a client has disconnected"); //data is type string
		redisClient.smembers("chatters", function(err, names) {
			names.forEach(function(name) {
				if (name == client.nickname) {
					client.broadcast.emit("remove chatter", name);
					redisClient.srem("chatters", name);
				}; // if
			}); // names
		}); // redisClient
	}); // client on

});

app.get('/', function (request, response) {
	
	response.sendfile(__dirname + '/chat.html')
})

server.listen(3000);





// app.get('/', function (request, response) {
//   response.send('Hello World')
// })


// app.get('/blog', function (request, response) {
// 	response.send('blog')
// })


// app.listen(3000);




